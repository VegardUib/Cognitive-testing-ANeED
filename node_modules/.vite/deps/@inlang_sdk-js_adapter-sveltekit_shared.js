import {
  addRuntimePromiseToEvent,
  addRuntimeToData,
  getRuntimeFromData,
  getRuntimePromiseFromEvent,
  replaceLanguageInUrl,
  wait
} from "./chunk-ULCBW442.js";
import "./chunk-2B2CG5KL.js";

// node_modules/@inlang/sdk-js/dist/adapter-sveltekit/runtime/shared/wrappers.js
import { browser } from "$app/environment";

// node_modules/@inlang/sdk-js/dist/detectors/matchLanguage.js
var matchLanguage = (detectedLanguages, languages, allowRelated = true) => {
  for (const detectedLanguage of detectedLanguages) {
    for (const language of languages) {
      if (language === detectedLanguage)
        return language;
    }
  }
  for (const detectedLanguage of detectedLanguages) {
    if (allowRelated) {
      const relatedLanguages = languages.map((language) => (language.startsWith(detectedLanguage + "-") || detectedLanguage.startsWith(language + "-")) && language).filter(Boolean).sort().sort((a, b) => a.split("-").length - b.split("-").length);
      if (relatedLanguages.length)
        return relatedLanguages[0];
    }
  }
  return void 0;
};

// node_modules/@inlang/sdk-js/dist/detectors/detectLanguage.js
var detectLanguage = async ({ referenceLanguage, languages, allowRelated = true }, ...detectors) => {
  const allDetectedLanguages = [];
  for (const detector of detectors) {
    const detectedLanguages = await detector();
    const matchedLanguage = matchLanguage(detectedLanguages, languages, false);
    if (matchedLanguage)
      return matchedLanguage;
    allDetectedLanguages.push(...detectedLanguages);
  }
  return allowRelated && matchLanguage(allDetectedLanguages, languages) || referenceLanguage;
};

// node_modules/@inlang/sdk-js/dist/adapter-sveltekit/runtime/client/runtime.js
import { base } from "$app/paths";

// node_modules/@inlang/sdk-js/dist/runtime/inlang-function.js
var createInlangFunction = (resource) => (key, args) => {
  const message = resource.body.find((message2) => message2.id.name === key);
  if (!message)
    return "";
  return message.pattern.elements.map((element) => serializeElement(element, args || {})).join("");
};
var serializeElement = (element, args) => {
  switch (element.type) {
    case "Text":
      return element.value;
    case "Placeholder": {
      return serializePlaceholder(element, args);
    }
  }
};
var serializePlaceholder = (placeholder, args) => {
  switch (placeholder.body.type) {
    case "VariableReference":
      return args[placeholder.body.name] || "";
  }
};

// node_modules/@inlang/sdk-js/dist/runtime/runtime.js
var isAsync = (p) => !!p && typeof p === "object" && typeof p.then === "function";
var fallbackInlangFunction = () => "";
var initBaseRuntime = ({ readResource }, state = {
  resources: /* @__PURE__ */ new Map(),
  language: void 0,
  i: void 0
}) => {
  const loadResourcePromises = /* @__PURE__ */ new Map();
  let isLoadResourceFunctionAsync = false;
  const loadResource = (language) => {
    if (state.resources.has(language))
      return isLoadResourceFunctionAsync ? Promise.resolve() : void 0;
    if (loadResourcePromises.has(language))
      return loadResourcePromises.get(language);
    const setResource = (resource) => resource && state.resources.set(language, resource);
    const resourceMaybePromise = readResource(language);
    if (!isAsync(resourceMaybePromise)) {
      setResource(resourceMaybePromise);
      return void 0;
    }
    isLoadResourceFunctionAsync = true;
    const promise = new Promise(async (resolve) => {
      const resource = await resourceMaybePromise;
      setResource(resource);
      loadResourcePromises.delete(language);
      resolve();
    });
    loadResourcePromises.set(language, promise);
    return promise;
  };
  const switchLanguage = (language) => {
    state.language = language;
    state.i = void 0;
  };
  const getLanguage = () => state.language;
  const getInlangFunction = () => {
    if (state.i)
      return state.i;
    const resource = state.resources.get(state.language);
    if (!resource)
      return fallbackInlangFunction;
    return state.i = createInlangFunction(resource);
  };
  return {
    loadResource,
    switchLanguage,
    get language() {
      return getLanguage();
    },
    get i() {
      return getInlangFunction();
    }
  };
};
var initRuntimeWithLanguageInformation = (context) => {
  const runtime = initBaseRuntime(context);
  return {
    ...runtime,
    get language() {
      return runtime.language;
    },
    get i() {
      return runtime.i;
    },
    get referenceLanguage() {
      return context.referenceLanguage;
    },
    get languages() {
      return context.languages;
    }
  };
};

// node_modules/@inlang/sdk-js/dist/adapter-sveltekit/runtime/client/runtime.js
var initSvelteKitClientRuntime = async ({ fetch, language, referenceLanguage, languages }) => {
  const runtime = initRuntimeWithLanguageInformation({
    readResource: async (language2) => fetch(`${base}/inlang/${language2}.json`).then((response) => response.ok ? response.json() : void 0),
    referenceLanguage,
    languages
  });
  if (language) {
    await runtime.loadResource(language);
    runtime.switchLanguage(language);
  }
  return runtime;
};

// node_modules/@inlang/sdk-js/dist/adapter-sveltekit/runtime/shared/wrappers.js
var initializedRuntime = {};
var initRuntimeForWrappers = async (event, options) => {
  const existingPromise = getRuntimePromiseFromEvent(event);
  if (existingPromise)
    return existingPromise;
  if (!options) {
    await wait(0);
    return initRuntimeForWrappers(event, options);
  }
  let resolveRuntimePromise = void 0;
  addRuntimePromiseToEvent(event, new Promise((resolve) => resolveRuntimePromise = resolve));
  const data = event.data;
  const { referenceLanguage = void 0, languages = [] } = data;
  const language = data.language || !options.initDetectors ? data.language : await detectLanguage({ referenceLanguage, languages }, ...options.initDetectors(event));
  const runtime = initializedRuntime[language] || await initSvelteKitClientRuntime({
    fetch: event.fetch,
    language,
    referenceLanguage,
    languages
  });
  resolveRuntimePromise(runtime);
  if (browser && language) {
    initializedRuntime = { [language]: runtime };
  }
  return runtime;
};
var initRootLayoutLoadWrapper = (options) => ({
  wrap: (load) => async (event) => {
    const runtime = await initRuntimeForWrappers(event, options);
    const payload = await load(event, runtime);
    return addRuntimeToData({
      ...payload || event.data,
      referenceLanguage: runtime.referenceLanguage,
      languages: runtime.languages,
      language: runtime.language
      // TODO: only pass this if `language` gets detected on server
    }, runtime);
  }
});
var initRootPageLoadWrapper = (options) => ({
  wrap: (load) => async (event) => {
    const data = await event.parent();
    const language = data.language;
    if (!language && options.browser) {
      const { referenceLanguage, languages } = data;
      if ((!language || !languages.includes(language)) && options.redirect) {
        const detectedLanguage = await detectLanguage({ referenceLanguage, languages }, ...options.initDetectors ? options.initDetectors(event) : []);
        throw options.redirect.throwable(307, options.redirect.getPath(event, detectedLanguage).toString());
      }
    }
    const runtime = await initRuntimeForWrappers(event);
    return load(event, runtime);
  }
});
var initLoadWrapper = () => ({
  wrap: (load) => async (event) => {
    const runtime = await initRuntimeForWrappers(event);
    return load(event, runtime);
  }
});
export {
  addRuntimePromiseToEvent,
  addRuntimeToData,
  getRuntimeFromData,
  getRuntimePromiseFromEvent,
  initLoadWrapper,
  initRootLayoutLoadWrapper,
  initRootPageLoadWrapper,
  replaceLanguageInUrl
};
//# sourceMappingURL=@inlang_sdk-js_adapter-sveltekit_shared.js.map
