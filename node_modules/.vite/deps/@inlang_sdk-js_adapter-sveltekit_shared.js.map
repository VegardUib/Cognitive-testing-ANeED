{
  "version": 3,
  "sources": ["../../@inlang/sdk-js/dist/adapter-sveltekit/runtime/shared/wrappers.js", "../../@inlang/sdk-js/dist/detectors/matchLanguage.js", "../../@inlang/sdk-js/dist/detectors/detectLanguage.js", "../../@inlang/sdk-js/dist/adapter-sveltekit/runtime/client/runtime.js", "../../@inlang/sdk-js/dist/runtime/inlang-function.js", "../../@inlang/sdk-js/dist/runtime/runtime.js"],
  "sourcesContent": ["import { browser } from \"$app/environment\";\nimport { detectLanguage } from \"../../../detectors/index.js\";\nimport { initSvelteKitClientRuntime } from \"../client/runtime.js\";\nimport { addRuntimePromiseToEvent, addRuntimeToData, getRuntimePromiseFromEvent, wait, } from \"./utils.js\";\n// ------------------------------------------------------------------------------------------------\nlet initializedRuntime = {};\nconst initRuntimeForWrappers = async (event, options) => {\n    const existingPromise = getRuntimePromiseFromEvent(event);\n    if (existingPromise)\n        return existingPromise;\n    if (!options) {\n        await wait(0);\n        return initRuntimeForWrappers(event, options);\n    }\n    let resolveRuntimePromise = undefined;\n    addRuntimePromiseToEvent(event, new Promise((resolve) => (resolveRuntimePromise = resolve)));\n    const data = event.data;\n    const { referenceLanguage = undefined, languages = [] } = data;\n    // TODO: only add this conditional logic if shared detection strategies get used\n    const language = data.language || !options.initDetectors\n        ? data.language\n        : await detectLanguage({ referenceLanguage, languages }, ...options.initDetectors(event));\n    const runtime = initializedRuntime[language] ||\n        (await initSvelteKitClientRuntime({\n            fetch: event.fetch,\n            language,\n            referenceLanguage,\n            languages,\n        }));\n    resolveRuntimePromise(runtime);\n    if (browser && language) {\n        initializedRuntime = { [language]: runtime };\n    }\n    return runtime;\n};\nexport const initRootLayoutLoadWrapper = (options) => ({\n    wrap: (load) => async (event) => {\n        const runtime = await initRuntimeForWrappers(event, options);\n        const payload = await load(event, runtime);\n        return addRuntimeToData({\n            ...(payload || event.data),\n            referenceLanguage: runtime.referenceLanguage,\n            languages: runtime.languages,\n            language: runtime.language, // TODO: only pass this if `language` gets detected on server\n        }, runtime);\n    },\n});\n// ------------------------------------------------------------------------------------------------\nexport const initRootPageLoadWrapper = (options) => ({\n    wrap: (load) => async (event) => {\n        const data = await event.parent();\n        const language = data.language;\n        if (!language && options.browser) {\n            const { referenceLanguage, languages } = data;\n            if ((!language || !languages.includes(language)) && options.redirect) {\n                const detectedLanguage = await detectLanguage({ referenceLanguage, languages }, ...(options.initDetectors ? options.initDetectors(event) : []));\n                throw options.redirect.throwable(307, options.redirect.getPath(event, detectedLanguage).toString());\n            }\n        }\n        const runtime = await initRuntimeForWrappers(event);\n        return load(event, runtime);\n    },\n});\n// ------------------------------------------------------------------------------------------------\nexport const initLoadWrapper = () => ({\n    wrap: (load) => async (event) => {\n        const runtime = await initRuntimeForWrappers(event);\n        return load(event, runtime);\n    },\n});\n", "/**\n * A function that takes one or more detected languages and matches them with the specified available languages.\n * Depending on the passed allowRelated parameter also related languages (\"en\" and \"en-GB\") are considered a match.\n * Related matches are only considered if no perfect matches can be found.\n * @param detectedLanguages The detected languages available for matching. Either an array of strings, a single string or undefined\n * @param languages A set of available languages (strings) for matching. Insertion order is irrelevant\n * @param allowRelated A boolean specifying whether related languages (\"en\" and \"en-US\") can be considered if no perfect match can be found in availableLanguages and detected\n * @returns Return string in case of a successful match or otherwise undefined\n */\nexport const matchLanguage = (detectedLanguages, languages, allowRelated = true) => {\n    for (const detectedLanguage of detectedLanguages) {\n        // check for perfect match\n        for (const language of languages) {\n            if (language === detectedLanguage)\n                return language;\n        }\n    }\n    for (const detectedLanguage of detectedLanguages) {\n        if (allowRelated) {\n            const relatedLanguages = languages\n                .map((language) => (language.startsWith(detectedLanguage + \"-\") ||\n                detectedLanguage.startsWith(language + \"-\")) &&\n                language)\n                .filter(Boolean)\n                // sort alphabetically\n                .sort()\n                // unspecific related languages should be preferred\n                .sort((a, b) => a.split(\"-\").length - b.split(\"-\").length);\n            if (relatedLanguages.length)\n                return relatedLanguages[0];\n        }\n    }\n    return undefined;\n};\n", "import { matchLanguage } from \"./matchLanguage.js\";\n/**\n * Takes a set of detection strategies and returns a language found in languages.\n * If no matching language can be found, the specified fallback Language will be returned.\n * @param params Function parameters\n * @param params.strategies A Set of detectors ordered by precedence (preferred first) (as JS Sets preserve insertion order).\n * These detectors have to be functions that return either an array of strings, a single string or undefined\n * @param params.referenceLanguage The language to fallback to if there is no detection match\n * @param params.languages Set of languages that are available for matching\n * @param params.allowRelated True if also related languages shall be considered a match.\n * detectLanguage will then return \"en\" from languages for a detected \"en-GB\" if no exact match can be found. It can also return \"en-GB\" from languages for a detected \"en\")\n * @returns The detected language\n */\nexport const detectLanguage = async ({ referenceLanguage, languages, allowRelated = true }, ...detectors) => {\n    const allDetectedLanguages = [];\n    for (const detector of detectors) {\n        const detectedLanguages = await detector();\n        const matchedLanguage = matchLanguage(detectedLanguages, languages, false);\n        if (matchedLanguage)\n            return matchedLanguage;\n        allDetectedLanguages.push(...detectedLanguages);\n    }\n    return (allowRelated && matchLanguage(allDetectedLanguages, languages)) || referenceLanguage;\n};\n", "import { base } from \"$app/paths\";\nimport { initRuntimeWithLanguageInformation } from \"../../../runtime/index.js\";\nexport const initSvelteKitClientRuntime = async ({ fetch, language, referenceLanguage, languages, }) => {\n    const runtime = initRuntimeWithLanguageInformation({\n        readResource: async (language) => fetch(`${base}/inlang/${language}.json`).then((response) => response.ok ? response.json() : undefined),\n        referenceLanguage,\n        languages,\n    });\n    if (language) {\n        await runtime.loadResource(language);\n        runtime.switchLanguage(language);\n    }\n    return runtime;\n};\n", "export const createInlangFunction = (resource) => ((key, args) => {\n    const message = resource.body.find((message) => message.id.name === key);\n    if (!message)\n        return \"\";\n    return message.pattern.elements\n        .map((element) => serializeElement(element, args || {}))\n        .join(\"\");\n});\nconst serializeElement = (element, args) => {\n    switch (element.type) {\n        case \"Text\":\n            return element.value;\n        case \"Placeholder\": {\n            return serializePlaceholder(element, args);\n        }\n    }\n};\nconst serializePlaceholder = (placeholder, args) => {\n    switch (placeholder.body.type) {\n        case \"VariableReference\":\n            return args[placeholder.body.name] || \"\";\n    }\n};\n", "import { createInlangFunction, } from \"./inlang-function.js\";\nexport const isAsync = (p) => !!p && typeof p === \"object\" && typeof p.then === \"function\";\nconst fallbackInlangFunction = () => \"\";\nexport const initRuntime = (context) => initBaseRuntime(context);\nexport const initBaseRuntime = ({ readResource }, state = {\n    resources: new Map(),\n    language: undefined,\n    i: undefined,\n}) => {\n    const loadResourcePromises = new Map();\n    let isLoadResourceFunctionAsync = false;\n    const loadResource = (language) => {\n        if (state.resources.has(language))\n            return isLoadResourceFunctionAsync\n                ? Promise.resolve()\n                : undefined;\n        if (loadResourcePromises.has(language))\n            return loadResourcePromises.get(language);\n        const setResource = (resource) => resource && state.resources.set(language, resource);\n        const resourceMaybePromise = readResource(language);\n        if (!isAsync(resourceMaybePromise)) {\n            setResource(resourceMaybePromise);\n            return undefined;\n        }\n        isLoadResourceFunctionAsync = true;\n        // eslint-disable-next-line no-async-promise-executor\n        const promise = new Promise(async (resolve) => {\n            const resource = await resourceMaybePromise;\n            setResource(resource);\n            loadResourcePromises.delete(language);\n            resolve();\n        });\n        loadResourcePromises.set(language, promise);\n        return promise;\n    };\n    const switchLanguage = (language) => {\n        state.language = language;\n        state.i = undefined;\n    };\n    const getLanguage = () => state.language;\n    const getInlangFunction = () => {\n        if (state.i)\n            return state.i;\n        const resource = state.resources.get(state.language);\n        if (!resource)\n            return fallbackInlangFunction;\n        return (state.i = createInlangFunction(resource));\n    };\n    return {\n        loadResource,\n        switchLanguage,\n        get language() {\n            return getLanguage();\n        },\n        get i() {\n            return getInlangFunction();\n        },\n    };\n};\nexport const initRuntimeWithLanguageInformation = (context) => {\n    const runtime = initBaseRuntime(context);\n    return {\n        ...runtime,\n        get language() {\n            return runtime.language;\n        },\n        get i() {\n            return runtime.i;\n        },\n        get referenceLanguage() {\n            return context.referenceLanguage;\n        },\n        get languages() {\n            return context.languages;\n        },\n    };\n};\n"],
  "mappings": "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",
  "names": ["message", "language"]
}
