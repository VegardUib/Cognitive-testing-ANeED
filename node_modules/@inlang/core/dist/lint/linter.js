import { createReportFunction } from "./report.js";
const getResourceForLanguage = (resources, language) => resources.find(({ languageTag }) => languageTag.name === language);
/**
 * Lints the given resources.
 *
 * The linted resources will be returned with lint information added to each node.
 * The returned errors are unexpected errors that occurred during linting, not
 * lint errors themselves.
 *
 * @example
 *   const [lintedResources, errors] = await lint({ config, resources })
 *   if (errors) {
 *     // handle unexpected errors during the linting process.
 *     // this errors are not lint errors themselves!
 *   }
 *   const lints = getLintReports(lintedResources, { options })
 */
export const lint = async (args) => {
    const { referenceLanguage, languages, lint } = args.config;
    const resources = structuredClone(args.resources);
    if (lint === undefined || lint.rules.length === 0) {
        return [args.resources, []];
    }
    const reference = getResourceForLanguage(resources, referenceLanguage);
    const errors = [];
    await Promise.all(lint.rules.flat().map((rule) => processLintRule({
        rule,
        referenceLanguage,
        languages,
        reference,
        resources,
    }).catch((e) => errors.push(new Error(`Unexpected error in lint rule '${rule.id}'`, { cause: e })))));
    return [resources, errors.length > 0 ? errors : undefined];
};
const processLintRule = async (args) => {
    const { referenceLanguage, languages, reference, resources } = args;
    const report = createReportFunction(args.rule);
    const { visitors } = await args.rule.setup({ config: { referenceLanguage, languages }, report });
    for (const language of languages) {
        await processResource({
            reference,
            target: getResourceForLanguage(resources, language),
            visitors,
        });
    }
};
// --------------------------------------------------------------------------------------------------------------------
const shouldProcessResourceChildren = (visitors) => !!visitors.Message || shouldProcessMessageChildren(visitors);
const processResource = async ({ visitors, target, reference, }) => {
    const payload = visitors.Resource && (await visitors.Resource({ target: target, reference }));
    if (payload === "skip") {
        return;
    }
    // process children
    if (shouldProcessResourceChildren(visitors)) {
        const processedReferenceMessages = new Set();
        for (const targetMessage of target?.body ?? []) {
            const referenceMessage = reference?.body.find(({ id }) => id.name === targetMessage.id.name);
            await processMessage({
                visitors,
                reference: referenceMessage,
                target: targetMessage,
            });
            if (referenceMessage) {
                processedReferenceMessages.add(referenceMessage.id.name);
            }
        }
        const nonVisitedReferenceMessages = reference?.body.filter(({ id }) => !processedReferenceMessages.has(id.name));
        for (const referenceNode of nonVisitedReferenceMessages ?? []) {
            await processMessage({
                visitors,
                reference: referenceNode,
                target: undefined,
            });
            processedReferenceMessages.add(referenceNode.id.name);
        }
    }
};
// --------------------------------------------------------------------------------------------------------------------
const shouldProcessMessageChildren = (visitors) => !!visitors.Pattern;
const processMessage = async ({ visitors, target, reference, }) => {
    const payload = visitors.Message && (await visitors.Message({ target, reference }));
    if (payload === "skip") {
        return;
    }
    // process children
    if (shouldProcessMessageChildren(visitors)) {
        await processPattern({
            visitors,
            reference: reference?.pattern,
            target: target?.pattern,
        });
    }
};
// --------------------------------------------------------------------------------------------------------------------
const processPattern = async ({ visitors, target, reference, }) => {
    const payload = visitors.Pattern && (await visitors.Pattern({ target, reference }));
    if (payload === "skip") {
        return;
    }
};
