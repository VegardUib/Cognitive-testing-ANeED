import type { Expression, Identifier, ImportDeclaration, Node, Program } from "estree";
import type { Result } from "@inlang/core/utilities";
import { type SyncHandler } from "estree-walker";
import type { Ast } from "../../../../node_modules/svelte/types/compiler/interfaces.js";
import { types } from "recast";
import type MagicStringImport from "magic-string";
import type { ExpressionKind } from "ast-types/gen/kinds.js";
export declare class FindAstError extends Error {
    #private;
}
type SyncHandlerParams = Parameters<SyncHandler>;
type FindAstConditionParameter<N extends types.namedTypes.Node | Node> = {
    node?: N | null;
    parent?: types.namedTypes.Node | Node | null;
    key?: SyncHandlerParams[2];
    index?: SyncHandlerParams[3];
};
type FindAstCondition<N extends types.namedTypes.Node | Node> = (parameter: FindAstConditionParameter<N>) => boolean;
export type NodeInfoMapEntry<P extends Node | types.namedTypes.Node | null> = {
    parent: P;
    key: P extends null ? undefined | null : keyof P;
    index: number | null | undefined;
    runOnNode: boolean;
};
export type NodeInfoMap<P extends Node | types.namedTypes.Node | null> = Map<Node | types.namedTypes.Node, NodeInfoMapEntry<P>>;
export type RunOn<N extends types.namedTypes.Node | Node, T> = (node: FindAstConditionParameter<N>["node"]) => ((meta: NodeInfoMap<types.namedTypes.Node | Node | null>) => T) | undefined;
export declare const findAstJs: (sourceAst: Node | types.namedTypes.Node, matchers: [FindAstCondition<Node | types.namedTypes.Node>, ...FindAstCondition<Node | types.namedTypes.Node>[]], runOn: RunOn<Node | types.namedTypes.Node, any>) => [undefined, FindAstError] | [any[], undefined];
export declare const findAstSvelte: (sourceAst: Ast, matchers: [FindAstCondition<Node | types.namedTypes.Node>, ...FindAstCondition<Node | types.namedTypes.Node>[]], runOn: RunOn<Node | types.namedTypes.Node, any>) => [undefined, FindAstError] | [any[], undefined];
export declare const findLoadDeclaration: (ast: types.namedTypes.Node | Node) => {
    node: types.namedTypes.VariableDeclarator;
}[];
export declare const emptyLoadExportNodes: () => import("ast-types/gen/kinds.js").StatementKind[];
export declare const makeMarkupReactive: (parsed: Ast, s: MagicStringImport.default, reactiveIdentifiers: string[]) => void;
export declare const sortMarkup: (parsed: Ast, s: MagicStringImport.default) => void;
export declare const makeJsReactive: (ast: types.namedTypes.Node, reactiveIdentifiers: string[]) => void;
export declare const getReactiveImportIdentifiers: (importNames: [string, string][]) => string[];
export declare const htmlIsEmpty: (htmlAst: Ast["html"]) => boolean;
export declare const functionMatchers: (name: string) => Parameters<typeof findAstJs>[1];
export declare const arrowFunctionMatchers: (name: string) => Parameters<typeof findAstJs>[1];
export declare const variableDeclaratorMatchers: (name: string) => Parameters<typeof findAstJs>[1];
export declare const findUsedImportsInAst: (ast: types.namedTypes.Node, availableImports?: [string, string][]) => [string, string][];
export declare const getFunctionOrDeclarationValue: (ast: types.namedTypes.Node, name: string, fallbackFunction?: ExpressionKind) => ExpressionKind;
export declare const variableDeclarationAst: (importNames: [string, string][]) => types.namedTypes.VariableDeclaration | undefined;
export declare const initImportedVariablesAst: (importNames: [string, string][]) => types.namedTypes.ExpressionStatement | undefined;
export declare const getRootReferenceIndexes: (ast: types.namedTypes.Node, names: [string, string][]) => number[] | undefined;
export declare class FindAliasError extends Error {
    #private;
}
type Alias = types.namedTypes.Expression | Expression | types.namedTypes.Identifier | Identifier;
export declare const findAlias: (ast: types.namedTypes.Node | Node, identifier: string, deep?: boolean, lastAlias?: Alias, ignore?: (types.namedTypes.Node | Node)[]) => Result<Alias, FindAliasError>;
export declare class FindDefinitionError extends Error {
    #private;
}
export declare const findDefinition: (ast: types.namedTypes.Node | Node, identifier: string, deep?: boolean, ignore?: (types.namedTypes.Node | Node)[], type?: "function") => Result<types.namedTypes.Node | Node, FindDefinitionError>;
export declare class IdentifierIsDeclarableError extends Error {
    #private;
}
export declare const identifierIsDeclarable: (ast: types.namedTypes.Node | Node, identifier: string) => Result<boolean, IdentifierIsDeclarableError>;
export declare class MergeNodesError extends Error {
    #private;
}
type Renamings = {
    originalName: types.namedTypes.Identifier | Identifier;
    newName: types.namedTypes.Expression | Expression | types.namedTypes.Identifier | Identifier;
    scope?: types.namedTypes.Node | Node;
}[];
export declare const mergeNodes: (ast: types.namedTypes.Node | Node, node: types.namedTypes.Node | Node, renamingScope?: types.namedTypes.Node | Node) => Result<Renamings, MergeNodesError>;
export declare const findDeclarableIdentifier: (ast: Node | types.namedTypes.Node, identifier: string) => string;
export declare class ImportsAddError extends Error {
    #private;
}
export declare class ImportsGetAliasesError extends Error {
    #private;
}
export declare const imports: (target: Program | types.namedTypes.Program, source: string) => {
    getAliases: (...exportNames: string[]) => {
        findReferences: () => [ImportDeclaration, ...ImportDeclaration[]] | undefined;
    } & ({
        aliases: Map<string, types.namedTypes.Identifier | types.namedTypes.MemberExpression>;
        error?: undefined;
    } | {
        aliases?: undefined;
        error: ImportsGetAliasesError;
    });
    add: (exportN: string, aliasN?: string) => {
        findReferences: () => [ImportDeclaration, ...ImportDeclaration[]] | undefined;
    } & {
        alias: types.namedTypes.Identifier | types.namedTypes.MemberExpression;
    };
    removeAll: () => any;
    findReferences: () => [ImportDeclaration, ...ImportDeclaration[]] | undefined;
};
export {};
//# sourceMappingURL=ast.d.ts.map