var _FindAstError_id, _FindAliasError_id, _FindDefinitionError_id, _IdentifierIsDeclarableError_id, _MergeNodesError_id, _ImportsAddError_id, _ImportsGetAliasesError_id;
import { walk as jsWalk } from "estree-walker";
import { walk as svelteWalk } from "svelte/compiler";
import { types } from "recast";
import { parseModule } from "magicast";
export class FindAstError extends Error {
    constructor() {
        super(...arguments);
        _FindAstError_id.set(this, "FindAstException");
    }
}
_FindAstError_id = new WeakMap();
// Insert element only if all ancestors match matchers
// find a nodes parent where the node matches and where all ancestors match
// Create a map for matchingNodes: Map<Node, matchedCount>
//
// TODO: rework error handling
const findAst = ((walker) => (sourceAst, matchers, runOn) => {
    const matchCount = new Map();
    const matches = [];
    const nodeInfoMap = new Map();
    // Find matching node, the corresponding parent and insertionPoint
    walker(sourceAst, {
        enter(node, parent, key, index) {
            nodeInfoMap.set(node, {
                parent,
                key: key,
                index,
                runOnNode: runOn(node) !== undefined,
            });
            const matchCountAncestor = !parent ? 0 : matchCount.get(parent) ?? 0;
            if (matchCountAncestor < matchers.length) {
                const matcher = matchers[matchCountAncestor];
                const isMatching = matcher ? matcher({ node, parent, key, index }) : false;
                if (isMatching) {
                    matchCount.set(node, matchCountAncestor + 1);
                    if (matchCountAncestor === matchers.length - 1)
                        matches.push(node);
                }
            }
            else
                this.skip();
        },
    });
    if (matches.length === 0)
        return [
            undefined,
            new Error("Can't find path in ast matching the passed matchers"),
        ];
    const runResults = [];
    for (const match of matches) {
        const matchPath = [];
        let currentNode = match;
        while (currentNode) {
            matchPath.splice(0, 0, currentNode);
            currentNode = nodeInfoMap.get(currentNode)?.parent;
        }
        // matchpath needs to contain one node that isInsertionRefNode
        const runOnNode = matchPath.find((node) => nodeInfoMap.get(node)?.runOnNode);
        const fn = runOn(runOnNode);
        if (!runOnNode)
            return [undefined, new Error("Can't find specified insertion point")];
        if (fn)
            runResults.push(fn(nodeInfoMap));
    }
    return [runResults, undefined];
});
export const findAstJs = findAst(jsWalk);
export const findAstSvelte = findAst(svelteWalk);
const n = types.namedTypes;
const b = types.builders;
const loadMatchers = [
    ({ node }) => n.ExportNamedDeclaration.check(node),
    ({ node }) => n.VariableDeclaration.check(node),
    ({ node }) => n.VariableDeclarator.check(node),
    ({ node }) => n.Identifier.check(node) && node.name === "load",
];
export const findLoadDeclaration = (ast) => findAstJs(ast, loadMatchers, (node) => n.VariableDeclarator.check(node)
    ? (meta) => {
        return { node, meta };
    }
    : undefined)[0] ?? [];
const emptyLoadFunction = `export const load = async () => {};`;
export const emptyLoadExportNodes = () => parseModule(emptyLoadFunction).$ast.body;
export const makeMarkupReactive = (parsed, s, reactiveIdentifiers) => {
    const { instance, module } = parsed;
    parsed.instance = undefined;
    parsed.module = undefined;
    const locations = findAstSvelte(parsed, [({ node }) => n.Identifier.check(node) && reactiveIdentifiers.includes(node.name)], (node) => n.Identifier.check(node) && Object.hasOwn(node, "start") && Object.hasOwn(node, "end")
        ? () => [node.start, node.end]
        : undefined)[0];
    //const s = new MagicString(options.content)
    // Prefix these exact locations with $signs by utilizing magicstring (which keeps the sourcemap intact)
    if (locations) {
        for (const [start] of locations) {
            s.appendLeft(+start, "$");
        }
    }
    parsed.instance = instance;
    parsed.module = module;
};
export const sortMarkup = (parsed, s) => {
    const { instance, module, css } = parsed;
    parsed.instance = undefined;
    parsed.module = undefined;
    parsed.css = undefined;
    const lastIndex = s.toString().length + 1;
    for (const child of parsed.html.children ?? []) {
        s.move(child.start, child.end, lastIndex);
    }
    // Leave tags that can not be wrapped at the beginning
    for (const child of parsed.html.children ?? []) {
        if (![
            "svelte:window",
            "svelte:document",
            "svelte:body",
            "svelte:head",
            "svelte:options",
        ].includes(child.name))
            s.move(child.start, child.end, lastIndex);
    }
    parsed.instance = instance;
    parsed.module = module;
    parsed.css = css;
};
export const makeJsReactive = (ast, reactiveIdentifiers) => {
    findAstJs(ast, [({ node }) => n.Identifier.check(node) && reactiveIdentifiers.includes(node.name)], (node) => (n.Identifier.check(node) ? () => (node.name = "$" + node.name) : undefined));
};
const inlangSdkJsStores = ["i", "language"];
export const getReactiveImportIdentifiers = (importNames) => importNames.flatMap(([imported, local]) => (inlangSdkJsStores.includes(imported) ? [local] : []));
// Taken from mozilla docs: https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#whitespace_helper_functions
function is_all_ws(s) {
    return !/[^\t\n\r ]/.test(s);
}
export const htmlIsEmpty = (htmlAst) => {
    if (htmlAst.children == undefined || htmlAst.children.length === 0)
        return true;
    return htmlAst.children.every((templateNode) => (templateNode.type === "Text" && is_all_ws(templateNode.data)) ||
        templateNode.type === "Comment");
};
export const functionMatchers = (name) => [
    ({ node }) => n.FunctionDeclaration.check(node),
    ({ node }) => n.Identifier.check(node) && node.name === name,
];
export const arrowFunctionMatchers = (name) => [
    ({ node }) => n.VariableDeclaration.check(node),
    ({ node }) => n.VariableDeclarator.check(node) && n.Identifier.check(node.id) && node.id.name === name,
    ({ node }) => n.ArrowFunctionExpression.check(node),
];
export const variableDeclaratorMatchers = (name) => [
    ({ node }) => n.VariableDeclaration.check(node),
    ({ node }) => n.VariableDeclarator.check(node) && n.Identifier.check(node.id) && node.id.name === name,
];
export const findUsedImportsInAst = (ast, availableImports = []) => {
    if (availableImports.length === 0)
        return [];
    else {
        const usedImportsLocal = (findAstJs(ast, [
            ({ node }) => n.Identifier.check(node) && availableImports.some(([, local]) => local === node.name),
        ], (node) => {
            return n.Identifier.check(node) ? () => node.name : undefined;
        })[0] ?? []);
        return availableImports.filter(([, local]) => usedImportsLocal.includes(local));
    }
};
// TODO @benjaminpreiss
// if load is an (arrow) function, extend the parameters.
// The 2nd parameter needs to be all imported vars from @inlang/sdk-js that are USED within the function.
// 1. For that we pass a list of available vars into the function
// 2. We filter that list for the vars that we find in the load function
// 3. if that list is not empty, we create the 2nd parameter object
export const getFunctionOrDeclarationValue = (ast, name, fallbackFunction = b.arrowFunctionExpression([], b.blockStatement([]))) => {
    const variableDeclarationValueSearchResults = findAstJs(ast, variableDeclaratorMatchers(name), (node) => n.VariableDeclarator.check(node) && node.init != undefined ? () => node.init : undefined)[0];
    const functionDeclarationSearchResults = findAstJs(ast, functionMatchers(name), (node) => n.FunctionDeclaration.check(node) ? () => node : undefined)[0];
    const variableDeclarationExpression = variableDeclarationValueSearchResults && variableDeclarationValueSearchResults.length > 0
        ? variableDeclarationValueSearchResults[0]
        : undefined;
    const functionDeclaration = functionDeclarationSearchResults && functionDeclarationSearchResults.length > 0
        ? b.functionExpression.from({
            async: functionDeclarationSearchResults[0].async,
            body: functionDeclarationSearchResults[0].body,
            params: functionDeclarationSearchResults[0].params,
            generator: functionDeclarationSearchResults[0].generator,
            id: functionDeclarationSearchResults[0].id,
        })
        : undefined;
    return variableDeclarationExpression ?? functionDeclaration ?? fallbackFunction;
};
export const variableDeclarationAst = (importNames) => importNames.length > 0
    ? b.variableDeclaration("let", importNames.map(([, local]) => b.variableDeclarator(b.identifier(local))))
    : undefined;
export const initImportedVariablesAst = (importNames) => importNames.length > 0
    ? b.expressionStatement(b.assignmentExpression("=", b.objectPattern(importNames.map(([imported, local]) => b.property("init", b.identifier(imported), b.identifier(local)))), b.callExpression(b.identifier("getRuntimeFromContext"), [])))
    : undefined;
export const getRootReferenceIndexes = (ast, names) => findAstJs(ast, [
    ({ node }) => n.Identifier.check(node) &&
        (names.some(([, local]) => local === node.name) || node.name === "data"),
], (node) => n.Identifier.check(node)
    ? (meta) => {
        let { parent, index } = meta.get(node) ?? {};
        while (parent != undefined && !n.Program.check(parent)) {
            const parentMeta = meta.get(parent);
            parent = parentMeta?.parent;
            index = parentMeta?.index;
        }
        if (n.Program.check(parent))
            return index;
        return undefined;
    }
    : undefined)[0];
// Returns true if all ancestors fulfill checks
// False if one ancestor breaks the chain
const typeCheckAncestors = (node, meta, ...typeChecks) => {
    let parent = node ? meta.get(node)?.parent : undefined;
    for (const check of typeChecks) {
        if (!check(parent))
            return false;
        parent = parent ? meta.get(parent)?.parent : undefined;
    }
    return true;
};
// Returns true if node was declared in a certain type of ancestry
const isDeclaredIn = (node, meta, type) => {
    const propertyCheck = (nd) => (n.Property.check(nd) || n.ObjectProperty.check(nd)) && nd.value === node;
    const objectPatternCheck = (node) => n.ObjectPattern.check(node);
    if (type === "ObjectPattern") {
        return typeCheckAncestors(node, meta, propertyCheck, objectPatternCheck);
    }
    return false;
};
// Is this identifier already assigned to another identifier?
//
// E.g. you want to merge `const {key: alias} = ...` and `const {key: anotherAlias} = ...`, then we know that `key` is already assigned to `alias`
// 2. `const {key: alias, ...rest} = ...` and `const {key2} = ...` then `key2` is assigned to `rest`
// 3. `const blue = ...` and `const {key} = ...` then `key` is assigned to `blue`
// Returns the identifier to which the requested identifier is already assigned
// Value is already assigned to identifier
export class FindAliasError extends Error {
    constructor() {
        super(...arguments);
        _FindAliasError_id.set(this, "FindAliasException");
    }
}
_FindAliasError_id = new WeakMap();
// MANIPULATES the passed ast!
export const findAlias = (ast, identifier, deep = false, lastAlias, ignore = []) => {
    let result = undefined;
    jsWalk(ast, {
        enter(node) {
            if (result !== undefined || ignore.includes(node)) {
                this.skip();
            }
            else if (n.ObjectPattern.check(node)) {
                let rest;
                for (const property of node.properties) {
                    const found = findAlias(property, identifier);
                    if (n.RestProperty.check(property))
                        rest = property.argument;
                    else if (found[0] !== undefined) {
                        result = found;
                        ignore.push(node);
                        this.skip();
                    }
                }
                if (result === undefined && rest !== undefined) {
                    result = [rest, undefined];
                    ignore.push(node);
                    this.skip();
                }
            }
            else if ((n.Property.check(node) || n.ObjectProperty.check(node)) &&
                ((n.Identifier.check(node.key) && node.key.name === identifier) ||
                    (n.Identifier.check(node.value) && node.value.name === identifier))) {
                result = [node.value, undefined];
                this.skip();
            }
            else if (n.FunctionDeclaration.check(node) && node.id != undefined) {
                const found = findAlias(node.id, identifier);
                if (found[0] !== undefined) {
                    result = found;
                    ignore.push(node);
                    this.skip();
                }
            }
            else if (n.VariableDeclaration.check(node)) {
                for (const declaration of node.declarations) {
                    const found = findAlias(declaration, identifier);
                    if (found[0] !== undefined) {
                        result = found;
                        ignore.push(node);
                        this.skip();
                    }
                }
            }
            else if (n.VariableDeclarator.check(node)) {
                const found = findAlias(node.id, identifier);
                // `blue = green` & `green` -> `blue`
                if (n.Identifier.check(node.init) &&
                    n.Identifier.check(node.id) &&
                    node.init.name === identifier) {
                    result = [node.id, undefined];
                    ignore.push(node);
                    this.skip();
                }
                // `blue = <anything else>` & `blue` -> `blue`
                else if (found[0] !== undefined) {
                    result = found;
                    ignore.push(node);
                    this.skip();
                }
            }
            else if (n.Identifier.check(node) && node.name === identifier) {
                result = [node, undefined];
                ignore.push(node);
                this.skip();
            }
        },
    });
    // Iterate through findAlias until no alias can be found
    if (result !== undefined) {
        if (result[0] !== undefined && deep) {
            if (lastAlias !== result[0] && n.Identifier.check(result[0])) {
                const nextAlias = findAlias(ast, result[0].name, true, result[0], ignore);
                if (nextAlias[0] !== undefined)
                    return nextAlias;
                else
                    return result;
            }
            return [
                undefined,
                new Error("Deep searching for aliases for MemberExpressions is not supported yet."),
            ];
        }
        return result;
    }
    return [
        undefined,
        new Error("Couldn't find alias or even the identifier itself"),
    ];
};
export class FindDefinitionError extends Error {
    constructor() {
        super(...arguments);
        _FindDefinitionError_id.set(this, "FindDefinitionException");
    }
}
_FindDefinitionError_id = new WeakMap();
// Finds the original definition value of the searched for identifier
// If supplied, also makes sure that the definition is of a specific type
export const findDefinition = (ast, identifier, deep = false, ignore = [], type) => {
    // Iterates through ast, looks for declarations.
    let result = undefined;
    jsWalk(ast, {
        enter(node) {
            if (result !== undefined || ignore.includes(node))
                this.skip();
            else if (n.VariableDeclarator.check(node) &&
                n.Identifier.check(node.id) &&
                node.id.name === identifier) {
                result = node.init ?? undefined;
                ignore.push(node);
                this.skip();
            }
            else if (n.FunctionDeclaration.check(node) &&
                n.Identifier.check(node.id) &&
                node.id.name === identifier) {
                result = node;
                ignore.push(node);
                this.skip();
            }
        },
    });
    if (result !== undefined) {
        if (deep) {
            if (n.Identifier.check(result))
                return findDefinition(ast, result.name, true, ignore, type);
            return [result, undefined];
        }
        return [result, undefined];
    }
    return [undefined, new Error("Couldn't find definition")];
};
export class IdentifierIsDeclarableError extends Error {
    constructor() {
        super(...arguments);
        _IdentifierIsDeclarableError_id.set(this, "IdentifierIsDeclarableException");
    }
}
_IdentifierIsDeclarableError_id = new WeakMap();
export const identifierIsDeclarable = (ast, identifier) => {
    try {
        const searchResults = (findAstJs(ast, [({ node }) => n.Identifier.check(node) && node.name === identifier], (node) => n.Identifier.check(node)
            ? (meta) => {
                // Is this name used as the value of an object pattern? If so, return false
                if (isDeclaredIn(node, meta, "ObjectPattern"))
                    return false;
                throw new Error("Cannot predict indentifier declarability for this ast.");
            }
            : undefined)[0] ?? [true]);
        return [searchResults.every((r) => r === true), undefined];
    }
    catch (error) {
        return [undefined, error];
    }
};
export class MergeNodesError extends Error {
    constructor() {
        super(...arguments);
        _MergeNodesError_id.set(this, "MergeNodesException");
    }
}
_MergeNodesError_id = new WeakMap();
// Merges nodes.
// If some things don't turn out to be as requested, try to rename stuff in the code (but only if a scope is provided). Otherwise return the stuff that has to be renamed
export const mergeNodes = (ast, node, renamingScope) => {
    if (n.ObjectPattern.check(node)) {
        for (const property of node.properties) {
            return mergeNodes(ast, property, renamingScope);
        }
    }
    else if (n.Property.check(node)) {
        if (n.Identifier.check(node.value)) {
            if (n.Identifier.check(node.key)) {
                if (identifierIsDeclarable(ast, node.value.name)[0] === true ||
                    node.key.name === node.value.name) {
                    if (n.ObjectPattern.check(ast)) {
                        const foundAlias = findAlias(ast, node.key.name)[0];
                        if (n.Identifier.check(foundAlias) && foundAlias.name === node.key.name)
                            return [[], undefined];
                        if (foundAlias !== undefined) {
                            return [
                                [
                                    {
                                        originalName: b.identifier(node.value.name),
                                        newName: foundAlias,
                                        scope: renamingScope,
                                    },
                                ],
                                undefined,
                            ];
                        }
                        ast.properties.push(node);
                    }
                    else if (n.Identifier.check(ast)) {
                        return [
                            [
                                {
                                    originalName: b.identifier(node.value.name),
                                    newName: b.memberExpression(ast, node.key),
                                    scope: renamingScope,
                                },
                            ],
                            undefined,
                        ];
                    }
                    else {
                        return [
                            undefined,
                            new Error("Cant merge Property into ast of different type"),
                        ];
                    }
                }
                else {
                    return [
                        undefined,
                        new Error("Some of the requested identifiers are already in use."),
                    ];
                }
            }
            else {
                return [undefined, new Error("Unsupported type for key of Property.")];
            }
        }
        else {
            return [undefined, new Error("Unsupported type for value of Property")];
        }
    }
    else if (n.FunctionDeclaration.check(node)) {
        if (node.id != undefined) {
            if (n.Identifier.check(node.id)) {
                // Find the function definition in the ast
                const searchResult = findDefinition(ast, node.id.name, true);
                const def = searchResult[0];
                if (searchResult[1] instanceof Error &&
                    searchResult[1].message === "Couldn't find definition")
                    return [undefined, new Error("Couldn't find a function to merge into")];
                else if (n.FunctionDeclaration.check(def) || n.ArrowFunctionExpression.check(def)) {
                    const renamings = [];
                    for (const [index, parameter] of node.params.entries()) {
                        const targetParameter = def.params[index];
                        if (targetParameter !== undefined) {
                            const mergeResult = mergeNodes(targetParameter, parameter, def.body);
                            if (mergeResult[0] !== undefined)
                                renamings.push(...mergeResult[0]);
                            else
                                return [
                                    undefined,
                                    new Error("Couldn't merge function parameters"),
                                ];
                        }
                        else
                            def.params.push(parameter);
                    }
                    return [renamings, undefined];
                }
                else {
                    return [
                        undefined,
                        new Error("Found variable declaration is not of type function"),
                    ];
                }
            }
            else {
                return [
                    undefined,
                    new Error("Cannot merge function that is identified by something other than an Identifier"),
                ];
            }
        }
        else {
            return [undefined, new Error("Can't merge anonymous function into an ast")];
        }
    }
    else if (n.ExportNamedDeclaration.check(node) && node.declaration) {
        if (n.ExportNamedDeclaration.check(ast) && ast.declaration) {
            return mergeNodes(ast.declaration, node.declaration, renamingScope);
        }
        else if (n.Program.check(ast)) {
            /* const mergeResults: Renamings = []
            const errors: MergeNodesError[] = []
            for (const statement of ast.body) {
                // This line is bad
                const [namingsStatement, errorStatement] = mergeNodes(
                    statement,
                    node.declaration,
                    renamingScope,
                )
                if (errorStatement instanceof Error) errors.push(errorStatement)
                else if (namingsStatement !== undefined) mergeResults.push(...namingsStatement)
            }
            if (errors.length === ast.body.length) {
                // There exists no function of this name. Push to body!
                if (
                    errors.every((error) => error.message === "Couldn't find a function to merge into") ||
                    errors[0] === undefined ||
                    ast.body.length === 0
                ) {
                    ast.body.push(node)
                }
                // Merge fails for other reasons
                else return [undefined, errors[0]]
            } */
            const mergeResult = mergeNodes(ast, node.declaration);
            if (mergeResult[1] instanceof Error &&
                mergeResult[1].message === "Couldn't find a function to merge into") {
                ast.body.push(node);
                return [[], undefined];
            }
            return mergeResult;
        }
    }
    return [[], undefined];
};
// This function cannot error.
export const findDeclarableIdentifier = (ast, identifier) => {
    let newIdentifier;
    jsWalk(ast, {
        enter(node) {
            if (newIdentifier !== undefined)
                this.skip();
            else if (n.ImportDeclaration.check(node)) {
                for (const specifier of node.specifiers) {
                    if (n.ImportSpecifier.check(specifier) && specifier.local.name === identifier) {
                        newIdentifier = findDeclarableIdentifier(ast, `${identifier}_`);
                        this.skip();
                    }
                }
            }
            else if (n.Identifier.check(node) && node.name === identifier) {
                newIdentifier = findDeclarableIdentifier(ast, `${identifier}_`);
                this.skip();
            }
        },
    });
    return newIdentifier === undefined ? identifier : newIdentifier;
};
export class ImportsAddError extends Error {
    constructor() {
        super(...arguments);
        _ImportsAddError_id.set(this, "ImportsAddException");
    }
}
_ImportsAddError_id = new WeakMap();
export class ImportsGetAliasesError extends Error {
    constructor() {
        super(...arguments);
        _ImportsGetAliasesError_id.set(this, "ImportsGetAliasesException");
    }
}
_ImportsGetAliasesError_id = new WeakMap();
export const imports = (target, source) => {
    const findReferences = () => {
        const references = [];
        jsWalk(target, {
            enter(node) {
                if (n.ImportDeclaration.check(node) &&
                    n.Literal.check(node.source) &&
                    node.source.value === source) {
                    references.push(node);
                    this.skip();
                }
            },
        });
        return references.length === 0
            ? undefined
            : references;
    };
    const base = {
        findReferences,
    };
    return {
        ...base,
        getAliases: function (...exportNames) {
            try {
                const matchingImports = this.findReferences();
                const aliases = new Map();
                // There are no matching imports -> Return aliases: undefined
                if (matchingImports === undefined)
                    return { ...this, aliases: aliases };
                // Construct map of aliases: exportN -> aliasN
                for (const { specifiers } of matchingImports) {
                    for (const specifier of specifiers) {
                        const newKey = specifier.type === "ImportDefaultSpecifier"
                            ? "default"
                            : specifier.type === "ImportNamespaceSpecifier"
                                ? "*"
                                : specifier.imported.name;
                        aliases.set(newKey, specifier.local);
                    }
                }
                // Extend map of aliases with requested exportNames
                for (const exportN of exportNames) {
                    if (!aliases.has(exportN)) {
                        const namespaceAlias = aliases.get("*");
                        if (n.Identifier.check(namespaceAlias))
                            aliases.set(exportN, b.memberExpression(namespaceAlias, b.identifier(exportN)));
                        else
                            throw new ImportsGetAliasesError(`The alias for ${exportN} does not exist. Maybe call imports(...).add() first?`);
                    }
                }
                return { ...this, aliases };
            }
            catch (error) {
                return { ...this, error: error };
            }
        },
        add: function (exportN, aliasN) {
            // The aliasN should be available. Find a declarable identifier.
            // This also goes through all import aliases to check for availability.
            const declarableIdentifier = findDeclarableIdentifier(target, aliasN ?? exportN);
            // Can the import be added?
            // Y -> Proceed
            const matchingImports = this.findReferences();
            if (
            // There has to be one line that does not include a namespace import
            matchingImports === undefined ||
                (matchingImports.some(({ specifiers }) => specifiers.every((specifier) => n.ImportSpecifier.check(specifier) || n.ImportDefaultSpecifier.check(specifier))) &&
                    // exportN cannot be used already
                    matchingImports.every(({ specifiers }) => specifiers.every((specifier) => specifier.type === "ImportSpecifier"
                        ? specifier.imported.name !== exportN
                        : specifier.type === "ImportDefaultSpecifier"
                            ? exportN !== "default"
                            : exportN !== "*")))) {
                const localIdentifier = declarableIdentifier !== exportN ? b.identifier(declarableIdentifier) : undefined;
                const newImportSpecifierAst = exportN === "*"
                    ? b.importNamespaceSpecifier(localIdentifier)
                    : exportN === "default"
                        ? b.importDefaultSpecifier(localIdentifier)
                        : b.importSpecifier(b.identifier(exportN), localIdentifier);
                // Should we add a new line?
                // Y -> Append new line
                // N -> Push specifier into existing import
                if (exportN === "*" || matchingImports === undefined) {
                    const newImportDeclarationAst = b.importDeclaration([newImportSpecifierAst], b.literal(source));
                    target.body.splice(0, 0, newImportDeclarationAst);
                }
                else {
                    // Find the right line to add import
                    const insertionPoint = matchingImports.find(({ specifiers }) => specifiers.every((specifier) => n.ImportSpecifier.check(specifier) || n.ImportDefaultSpecifier.check(specifier)));
                    insertionPoint?.specifiers.push(newImportSpecifierAst);
                }
            }
            // Return changed identifiers
            const newAliasN = this.getAliases(exportN).aliases?.get(exportN);
            return { ...this, alias: newAliasN };
        },
        removeAll: function () {
            const matchingImports = this.findReferences();
            if (matchingImports !== undefined) {
                for (const declaration of matchingImports) {
                    const indexToRemove = target.body.findIndex((statement) => statement === declaration);
                    target.body.splice(indexToRemove, 1);
                }
            }
            return this;
        },
    };
};
