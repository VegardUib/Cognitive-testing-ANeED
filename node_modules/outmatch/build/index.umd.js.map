{"version":3,"file":"index.umd.js","sources":["../src/expand.ts","../src/negate.ts","../src/common.ts","../src/entities.ts","../src/convert.ts","../src/index.ts"],"sourcesContent":["'use strict'\n\nfunction handleNoCommaBraces(span: string) {\n  if (span.length < 3) {\n    return `{${span}}`\n  }\n\n  let separatorI = -1\n\n  for (let i = 2; i < span.length; i++) {\n    if (span[i] === '.' && span[i - 1] === '.' && (i < 2 || span[i - 2] !== '\\\\')) {\n      if (separatorI > -1) {\n        return `{${span}}`\n      }\n\n      separatorI = i - 1\n    }\n  }\n\n  if (separatorI > -1) {\n    let rangeStart = span.substr(0, separatorI)\n    let rangeEnd = span.substr(separatorI + 2)\n\n    if (rangeStart.length > 0 && rangeEnd.length > 0) {\n      return `[${span.substr(0, separatorI)}-${span.substr(separatorI + 2)}]`\n    }\n  }\n\n  return `{${span}}`\n}\n\nfunction expand(pattern: string): string[] {\n  if (typeof pattern !== 'string') {\n    throw new TypeError(`A pattern must be a string, but ${typeof pattern} given`)\n  }\n\n  let scanning = false\n  let openingBraces = 0\n  let closingBraces = 0\n  let handledUntil = -1\n  let results = ['']\n  let alternatives = []\n  let span\n\n  for (let i = 0; i < pattern.length; i++) {\n    let char = pattern[i]\n\n    if (char === '\\\\') {\n      i++\n      continue\n    }\n\n    if (char === '{') {\n      if (scanning) {\n        openingBraces++\n      } else if (i > handledUntil && !openingBraces) {\n        span = pattern.substring(handledUntil + 1, i)\n        for (let j = 0; j < results.length; j++) {\n          results[j] += span\n        }\n        alternatives = []\n        handledUntil = i\n        scanning = true\n        openingBraces++\n      } else {\n        openingBraces--\n      }\n    } else if (char === '}') {\n      if (scanning) {\n        closingBraces++\n      } else if (closingBraces === 1) {\n        span = pattern.substring(handledUntil + 1, i)\n\n        if (alternatives.length > 0) {\n          let newResults = []\n          alternatives.push(expand(span))\n          for (let j = 0; j < results.length; j++) {\n            for (let k = 0; k < alternatives.length; k++) {\n              for (let l = 0; l < alternatives[k].length; l++) {\n                newResults.push(results[j] + alternatives[k][l])\n              }\n            }\n          }\n          results = newResults\n        } else {\n          span = handleNoCommaBraces(span)\n          for (let j = 0; j < results.length; j++) {\n            results[j] += span\n          }\n        }\n\n        handledUntil = i\n        closingBraces--\n      } else {\n        closingBraces--\n      }\n    } else if (!scanning && char === ',' && closingBraces - openingBraces === 1) {\n      // closingBraces - openingBraces === 1 means we are in top-level braces\n      span = pattern.substring(handledUntil + 1, i)\n      alternatives.push(expand(span))\n      handledUntil = i\n    }\n\n    if (scanning && (closingBraces === openingBraces || i === pattern.length - 1)) {\n      scanning = false\n      i = handledUntil - 1\n    }\n  }\n\n  if (handledUntil === -1) {\n    return [pattern]\n  }\n\n  let unhandledFrom = pattern[handledUntil] === '{' ? handledUntil : handledUntil + 1\n  if (unhandledFrom < pattern.length) {\n    span = pattern.substr(unhandledFrom)\n    for (let j = 0; j < results.length; j++) {\n      results[j] += span\n    }\n  }\n\n  return results\n}\n\nexport default expand\n","import { OutmatchOptions } from './common'\n\nfunction negate(pattern: string, options: OutmatchOptions) {\n  let supportNegation = options['!'] !== false\n  let supportParens = options['()'] !== false\n  let isNegated = false\n  let i: number\n\n  if (supportNegation) {\n    // Consume leading !s unless the next char is an opening paren. At this point we can't\n    // be sure if it's a valid negated glob or just a wild paren, so this can produce false results.\n    for (i = 0; i < pattern.length && pattern[i] === '!'; i++) {\n      if (supportParens && pattern[i + 1] === '(') {\n        i--\n        break\n      }\n      isNegated = !isNegated\n    }\n\n    if (i > 0) {\n      pattern = pattern.substr(i)\n    }\n  }\n\n  return { pattern, isNegated }\n}\n\nexport default negate\n","interface OutmatchOptions {\n  separator?: boolean | string\n  flags?: string\n  excludeDot?: boolean\n  '!'?: boolean\n  '?'?: boolean\n  '*'?: boolean\n  '**'?: boolean\n  '[]'?: boolean\n  '()'?: boolean\n  '{}'?: boolean\n}\n\nfunction escapeRegExpChar(char: string) {\n  if (\n    char === '-' ||\n    char === '^' ||\n    char === '$' ||\n    char === '+' ||\n    char === '.' ||\n    char === '(' ||\n    char === ')' ||\n    char === '|' ||\n    char === '[' ||\n    char === ']' ||\n    char === '{' ||\n    char === '}' ||\n    char === '*' ||\n    char === '?' ||\n    char === '\\\\'\n  ) {\n    return `\\\\${char}`\n  } else {\n    return char\n  }\n}\n\nfunction escapeRegExpString(str: string) {\n  let result = ''\n  for (let i = 0; i < str.length; i++) {\n    result += escapeRegExpChar(str[i])\n  }\n  return result\n}\n\nexport { OutmatchOptions, escapeRegExpChar, escapeRegExpString }\n","import { escapeRegExpString, OutmatchOptions } from './common'\n\nfunction Pattern(source: string, options: OutmatchOptions, excludeDot: boolean) {\n  let separator = typeof options.separator === 'undefined' ? true : options.separator\n  let separatorSplitter = ''\n  let separatorMatcher = ''\n  let wildcard = '.'\n\n  if (separator === true) {\n    // In this case forward slashes in patterns match both forward and backslashes in samples\n    separatorSplitter = '/'\n    separatorMatcher = '[/\\\\\\\\]'\n    wildcard = '[^/\\\\\\\\]'\n  } else if (separator) {\n    separatorSplitter = separator\n    separatorMatcher = escapeRegExpString(separatorSplitter)\n\n    if (separatorMatcher.length > 1) {\n      separatorMatcher = `(?:${separatorMatcher})`\n      wildcard = `((?!${separatorMatcher}).)`\n    } else {\n      wildcard = `[^${separatorMatcher}]`\n    }\n  } else {\n    wildcard = '.'\n  }\n\n  // When a separator is explicitly specified in a pattern, it must match _one or more_\n  // separators in a sample, so we use quantifiers. When a pattern doesn't have a trailing\n  // separator, a sample can still optionally have them, so we use different quantifiers\n  // depending on the index of a segment.\n  let requiredSeparator = separator ? `${separatorMatcher}+?` : ''\n  let optionalSeparator = separator ? `${separatorMatcher}*?` : ''\n\n  let segments = separator ? source.split(separatorSplitter) : [source]\n\n  let support = {\n    qMark: options['?'] !== false,\n    star: options['*'] !== false,\n    globstar: separator && options['**'] !== false,\n    brackets: options['[]'] !== false,\n    extglobs: options['()'] !== false,\n    // The excludeDot function argument is for cases when we don't want to exclude leading\n    // dots even if the option is true (negated patterns).\n    excludeDot: excludeDot && options.excludeDot !== false,\n  }\n\n  return {\n    source,\n    segments,\n    options,\n    separator,\n    separatorSplitter,\n    separatorMatcher,\n    optionalSeparator,\n    requiredSeparator,\n    wildcard,\n    support,\n  }\n}\n\nfunction Segment(\n  source: string,\n  pattern: ReturnType<typeof Pattern>,\n  isFirst: boolean,\n  isLast: boolean\n) {\n  return {\n    source,\n    isFirst,\n    isLast,\n    end: source.length - 1,\n  }\n}\n\nfunction Result() {\n  // To support negated extglobs, we maintain two result patterns called `match` and `unmatch`.\n  // They are built identically except for two things:\n  // 1. Negated extglobs.\n  //    In `match` they become `wildcard + *`, i.e. \"match everything but the separator\".\n  //    In `unmatch` they become a regular positive regexp group.\n  // 2. Patterns for excluding leading dots.\n  //    They are added to `match` and skipped in `unmatch`.\n  // `useUnmatch` is set to true if we actually encounter a negated extglob. In that case\n  // the returned pattern is `'(?!^' + unmatch + '$)' + match`, otherwise it's just `match`.\n  return {\n    match: '',\n    unmatch: '',\n    useUnmatch: false,\n  }\n}\n\nfunction State(\n  pattern: ReturnType<typeof Pattern>,\n  segment: ReturnType<typeof Segment>,\n  result: ReturnType<typeof Result>\n) {\n  return {\n    pattern,\n    segment,\n    result,\n    openingBracket: segment.end + 1,\n    closingBracket: -1,\n    openingParens: 0,\n    closingParens: 0,\n    parensHandledUntil: -1,\n    extglobModifiers: [] as string[],\n    scanningForParens: false,\n    escapeChar: false,\n    addToMatch: true,\n    addToUnmatch: pattern.support.extglobs,\n    // We need to add the dot exclusion pattern before a segment only if it starts\n    // with a wildcard and not a literal character.\n    dotHandled: false,\n    i: -1,\n    char: '',\n    nextChar: '',\n  }\n}\n\nexport { Pattern, Segment, Result, State }\n","import { Pattern, Segment, Result, State } from './entities'\nimport { escapeRegExpChar, OutmatchOptions } from './common'\n\n// We use typescript-transform-macros to inline functions that handle various glob features.\n// These functions are called for every char in a pattern, and using them without explicit\n// inlining degrades performance. Having them in a separate file would be nice, but it\n// isn't supported, unfortunately.\ndeclare function MACRO<T>(t: T): T\n\n// This is used in place of the return value in inlined functions to skip to the next char\nconst CONTINUE = MACRO(() => {\n  // @ts-expect-error\n  continue\n})\n\nconst EXCLUDE_DOT_PATTERN = '(?!\\\\.)'\n\nfunction add(state: ReturnType<typeof State>, addition: string, excludeDot?: boolean) {\n  if (state.addToUnmatch) {\n    state.result.unmatch += addition\n  }\n\n  if (state.addToMatch) {\n    if (excludeDot && !state.dotHandled) {\n      addition = EXCLUDE_DOT_PATTERN + addition\n    }\n\n    state.dotHandled = true\n    state.result.match += addition\n  }\n\n  return state.result\n}\n\nconst convertEscaping = MACRO((state: ReturnType<typeof State>) => {\n  // The straightforward way to handle escaping would be to add the next character\n  // to the result as soon as a backslash is found and skip the rest of the current iteration.\n  // However, some processing has to be triggered for the last char in a pattern no matter\n  // if it is escaped or not, so we can't do this. Instead, we set the escapeChar flag\n  // for the next char and handle it in the next iteration (in which we have to be\n  // extra careful to reset the flag whenever the iteration completes or continues)\n  if (state.char === '\\\\') {\n    if (state.i < state.segment.end) {\n      state.escapeChar = true\n      return CONTINUE()\n    } else {\n      // If the last char in a pattern is a backslash, it is ignored\n      state.char = ''\n    }\n  }\n})\n\nconst convertBrackets = MACRO((state: ReturnType<typeof State>) => {\n  let { pattern, segment, char, i } = state\n\n  if (pattern.support.brackets && !state.scanningForParens) {\n    if (i > state.openingBracket && i <= state.closingBracket) {\n      // We are certainly in a complete character class\n      // and should treat almost all characters literally\n      if (state.escapeChar) {\n        add(state, escapeRegExpChar(char))\n      } else if (i === state.closingBracket) {\n        add(state, ']')\n        state.openingBracket = segment.source.length\n      } else if (char === '-' && i === state.closingBracket - 1) {\n        add(state, '\\\\-')\n      } else if (char === '!' && i === state.openingBracket + 1) {\n        add(state, '^')\n      } else if (char === ']') {\n        add(state, '\\\\]')\n      } else {\n        add(state, char)\n      }\n      state.escapeChar = false\n      return CONTINUE()\n    }\n\n    if (i > state.openingBracket) {\n      // We are in an open character class and are looking for a closing bracket\n      // to make sure the class is terminated\n      if (\n        char === ']' &&\n        !state.escapeChar &&\n        i > state.openingBracket + 1 &&\n        i > state.closingBracket\n      ) {\n        // Closing bracket is found; return to openingBracket\n        // and treat all the in-between chars literally\n        state.closingBracket = i\n        state.i = state.openingBracket\n        if (pattern.separator) {\n          add(state, `(?!${pattern.separatorMatcher})[`, true)\n        } else {\n          add(state, '[', true)\n        }\n      } else if (i === segment.end) {\n        // Closing bracket is not found; return to the opening bracket\n        // and treat all the in-between chars as usual\n        add(state, '\\\\[')\n        state.i = state.openingBracket\n        state.openingBracket = segment.source.length\n        state.closingBracket = segment.source.length\n      }\n      state.escapeChar = false\n      return CONTINUE()\n    }\n\n    // An opening bracket is found; commence scanning for a closing bracket\n    if (\n      char === '[' &&\n      !state.escapeChar &&\n      i > state.closingBracket &&\n      i < segment.end\n    ) {\n      state.openingBracket = i\n      state.escapeChar = false\n      return CONTINUE()\n    }\n  }\n})\n\nconst convertExtglob = MACRO((state: ReturnType<typeof State>) => {\n  if (state.pattern.support.extglobs) {\n    let { extglobModifiers, char, nextChar, i } = state\n\n    // When we find an opening extglob paren, we start counting opening and closing\n    // parens and ignoring other chars until all the opened extglobes are closed\n    // or the pattern ends. After we have counted the parens, we return to the char\n    // we started from and proceed normally while transforming the extglobs that have\n    // a closing paren.\n    if (\n      nextChar === '(' &&\n      !state.escapeChar &&\n      (char === '@' || char === '?' || char === '*' || char === '+' || char === '!')\n    ) {\n      if (state.scanningForParens) {\n        state.openingParens++\n      } else if (i > state.parensHandledUntil && !state.closingParens) {\n        state.parensHandledUntil = i\n        state.scanningForParens = true\n        state.openingParens++\n      } else if (state.closingParens >= state.openingParens) {\n        if (char === '!') {\n          state.addToMatch = true\n          state.addToUnmatch = false\n          add(state, `${state.pattern.wildcard}*?`, true)\n          state.addToMatch = false\n          state.addToUnmatch = true\n          state.result.useUnmatch = true\n        }\n        extglobModifiers.push(char)\n        add(state, '(?:', true)\n        state.openingParens--\n        state.i++\n        return CONTINUE()\n      } else {\n        state.openingParens--\n      }\n    } else if (char === ')' && !state.escapeChar) {\n      if (state.scanningForParens) {\n        state.closingParens++\n      } else if (extglobModifiers.length) {\n        let modifier = extglobModifiers.pop()\n        if (modifier === '!' && extglobModifiers.indexOf('!') !== -1) {\n          throw new Error(\"Nested negated extglobs aren't supported\")\n        }\n        modifier = modifier === '!' || modifier === '@' ? '' : modifier\n        add(state, `)${modifier}`)\n        state.addToMatch = true\n        state.addToUnmatch = true\n        state.closingParens--\n        return CONTINUE()\n      }\n    } else if (\n      char === '|' &&\n      state.closingParens &&\n      !state.scanningForParens &&\n      !state.escapeChar\n    ) {\n      add(state, '|')\n      return CONTINUE()\n    }\n\n    if (state.scanningForParens) {\n      if (state.closingParens === state.openingParens || i === state.segment.end) {\n        state.scanningForParens = false\n        state.i = state.parensHandledUntil - 1\n      }\n      state.escapeChar = false\n      return CONTINUE()\n    }\n  }\n})\n\nconst convertSingleChar = MACRO((state: ReturnType<typeof State>) => {\n  let { pattern } = state\n  let { support } = pattern\n\n  if (!state.escapeChar && support.star && state.char === '*') {\n    if (state.i === state.segment.end || state.nextChar !== '*') {\n      add(state, `${pattern.wildcard}*?`, true)\n    }\n  } else if (!state.escapeChar && support.qMark && state.char === '?') {\n    add(state, pattern.wildcard, true)\n  } else {\n    add(state, escapeRegExpChar(state.char))\n  }\n})\n\nfunction convertSegment(\n  pattern: ReturnType<typeof Pattern>,\n  segment: ReturnType<typeof Segment>,\n  result: ReturnType<typeof Result>\n) {\n  let { support } = pattern\n  let state = State(pattern, segment, result)\n  let separatorMatcher = segment.isLast\n    ? pattern.optionalSeparator\n    : pattern.requiredSeparator\n\n  if (!support.excludeDot) {\n    state.dotHandled = true\n  }\n\n  if (segment.end === -1) {\n    return segment.isLast && !segment.isFirst ? result : add(state, separatorMatcher)\n  }\n\n  if (support.globstar && segment.source === '**') {\n    let prefix = !state.dotHandled ? EXCLUDE_DOT_PATTERN : ''\n    let globstarSegment = `${prefix + pattern.wildcard}*?${separatorMatcher}`\n    return add(state, `(?:${globstarSegment})*?`)\n  }\n\n  while (++state.i <= segment.end) {\n    state.char = state.segment.source[state.i]\n    state.nextChar = state.i < segment.end ? segment.source[state.i + 1] : ''\n\n    // The order is important\n    convertEscaping(state)\n    convertBrackets(state)\n    convertExtglob(state)\n    convertSingleChar(state)\n\n    state.escapeChar = false\n  }\n\n  return add(state, separatorMatcher)\n}\n\nfunction convert(source: string, options: OutmatchOptions, excludeDot: boolean) {\n  let pattern = Pattern(source, options, excludeDot)\n  let result = Result()\n  let { segments } = pattern\n\n  for (let i = 0; i < segments.length; i++) {\n    let segment = Segment(segments[i], pattern, i === 0, i === segments.length - 1)\n    convertSegment(pattern, segment, result)\n  }\n\n  if (result.useUnmatch) {\n    return `(?!^${result.unmatch}$)${result.match}`\n  } else {\n    return result.match\n  }\n}\n\nexport default convert\n","import type { OutmatchOptions } from './common'\nimport expand from './expand'\nimport negate from './negate'\nimport convert from './convert'\n\nfunction flatMap<T, R>(array: Array<T>, predicate: (arg: T) => Array<R>) {\n  let results = []\n  for (let i = 0; i < array.length; i++) {\n    let mappedValue = predicate(array[i])\n    for (let j = 0; j < mappedValue.length; j++) {\n      results.push(mappedValue[j])\n    }\n  }\n  return results\n}\n\nfunction compile(patterns: string | string[], options: OutmatchOptions) {\n  patterns = Array.isArray(patterns) ? patterns : [patterns]\n\n  if (options['{}'] !== false) {\n    patterns = flatMap(patterns, expand)\n  }\n\n  let positiveResults = []\n  let negativeResults = []\n  let result = ''\n\n  for (let i = 0; i < patterns.length; i++) {\n    let negatedPattern = negate(patterns[i], options)\n    let convertedPattern = convert(\n      negatedPattern.pattern,\n      options,\n      !negatedPattern.isNegated\n    )\n\n    if (negatedPattern.isNegated) {\n      negativeResults.push(convertedPattern)\n    } else {\n      positiveResults.push(convertedPattern)\n    }\n  }\n\n  if (negativeResults.length) {\n    result = `(?!(?:${negativeResults.join('|')})$)`\n  }\n\n  if (positiveResults.length > 1) {\n    result += `(?:${positiveResults.join('|')})`\n  } else if (positiveResults.length === 1) {\n    result += positiveResults[0]\n  } else if (result.length) {\n    result += convert('**', options, true)\n  }\n\n  return `^${result}$`\n}\n\ninterface isMatch {\n  /**\n   * Tests if a sample string matches the pattern(s)\n   *\n   * ```js\n   * isMatch('foo') //=> true\n   * ```\n   */\n  (sample: string): boolean\n\n  /** The compiled regular expression */\n  regexp: RegExp\n\n  /** The original pattern or array of patterns that was used to compile the RegExp */\n  pattern: string | string[]\n\n  /** The options that were used to compile the RegExp */\n  options: OutmatchOptions\n}\n\nfunction isMatch(regexp: RegExp, sample: string) {\n  if (typeof sample !== 'string') {\n    throw new TypeError(`Sample must be a string, but ${typeof sample} given`)\n  }\n\n  return regexp.test(sample)\n}\n\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns true\n * if the string matches the pattern(s).\n *\n * ```js\n * outmatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = outmatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction outmatch(\n  pattern: string | string[],\n  options?: OutmatchOptions | string | boolean\n): isMatch {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError(\n      `The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`\n    )\n  }\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    options = { separator: options }\n  }\n\n  if (\n    arguments.length === 2 &&\n    !(\n      typeof options === 'undefined' ||\n      (typeof options === 'object' && options !== null && !Array.isArray(options))\n    )\n  ) {\n    throw new TypeError(\n      `The second argument must be an options object or a string/boolean separator, but ${typeof options} given`\n    )\n  }\n\n  options = options || {}\n\n  if (options.separator === '\\\\') {\n    throw new Error('\\\\ is not a valid separator')\n  }\n\n  let regexpPattern = compile(pattern, options)\n  let regexp = new RegExp(regexpPattern, options.flags)\n\n  let fn = isMatch.bind(null, regexp) as isMatch\n  fn.options = options\n  fn.pattern = pattern\n  fn.regexp = regexp\n  return fn\n}\n\nexport default outmatch\n"],"names":["handleNoCommaBraces","span","length","separatorI","i","rangeStart","substr","rangeEnd","expand","pattern","TypeError","scanning","openingBraces","closingBraces","handledUntil","results","alternatives","char","substring","j","newResults","push","k","l","unhandledFrom","negate","options","supportNegation","supportParens","isNegated","escapeRegExpChar","Pattern","source","excludeDot","separator","separatorSplitter","separatorMatcher","wildcard","str","result","escapeRegExpString","requiredSeparator","optionalSeparator","segments","split","support","qMark","star","globstar","brackets","extglobs","Segment","isFirst","isLast","end","EXCLUDE_DOT_PATTERN","add","state","addition","addToUnmatch","unmatch","addToMatch","dotHandled","match","convertSegment","segment","openingBracket","closingBracket","openingParens","closingParens","parensHandledUntil","extglobModifiers","scanningForParens","escapeChar","nextChar","State","modifier_1","pop","indexOf","Error","useUnmatch","convert","compile","patterns","Array","isArray","array","predicate","mappedValue","flatMap","positiveResults","negativeResults","negatedPattern","convertedPattern","join","isMatch","regexp","sample","test","arguments","regexpPattern","RegExp","flags","fn","bind"],"mappings":"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"}