{"version":3,"file":"index.es.mjs","sources":["../src/expand.ts","../src/negate.ts","../src/common.ts","../src/entities.ts","../src/convert.ts","../src/index.ts"],"sourcesContent":["'use strict'\n\nfunction handleNoCommaBraces(span: string) {\n  if (span.length < 3) {\n    return `{${span}}`\n  }\n\n  let separatorI = -1\n\n  for (let i = 2; i < span.length; i++) {\n    if (span[i] === '.' && span[i - 1] === '.' && (i < 2 || span[i - 2] !== '\\\\')) {\n      if (separatorI > -1) {\n        return `{${span}}`\n      }\n\n      separatorI = i - 1\n    }\n  }\n\n  if (separatorI > -1) {\n    let rangeStart = span.substr(0, separatorI)\n    let rangeEnd = span.substr(separatorI + 2)\n\n    if (rangeStart.length > 0 && rangeEnd.length > 0) {\n      return `[${span.substr(0, separatorI)}-${span.substr(separatorI + 2)}]`\n    }\n  }\n\n  return `{${span}}`\n}\n\nfunction expand(pattern: string): string[] {\n  if (typeof pattern !== 'string') {\n    throw new TypeError(`A pattern must be a string, but ${typeof pattern} given`)\n  }\n\n  let scanning = false\n  let openingBraces = 0\n  let closingBraces = 0\n  let handledUntil = -1\n  let results = ['']\n  let alternatives = []\n  let span\n\n  for (let i = 0; i < pattern.length; i++) {\n    let char = pattern[i]\n\n    if (char === '\\\\') {\n      i++\n      continue\n    }\n\n    if (char === '{') {\n      if (scanning) {\n        openingBraces++\n      } else if (i > handledUntil && !openingBraces) {\n        span = pattern.substring(handledUntil + 1, i)\n        for (let j = 0; j < results.length; j++) {\n          results[j] += span\n        }\n        alternatives = []\n        handledUntil = i\n        scanning = true\n        openingBraces++\n      } else {\n        openingBraces--\n      }\n    } else if (char === '}') {\n      if (scanning) {\n        closingBraces++\n      } else if (closingBraces === 1) {\n        span = pattern.substring(handledUntil + 1, i)\n\n        if (alternatives.length > 0) {\n          let newResults = []\n          alternatives.push(expand(span))\n          for (let j = 0; j < results.length; j++) {\n            for (let k = 0; k < alternatives.length; k++) {\n              for (let l = 0; l < alternatives[k].length; l++) {\n                newResults.push(results[j] + alternatives[k][l])\n              }\n            }\n          }\n          results = newResults\n        } else {\n          span = handleNoCommaBraces(span)\n          for (let j = 0; j < results.length; j++) {\n            results[j] += span\n          }\n        }\n\n        handledUntil = i\n        closingBraces--\n      } else {\n        closingBraces--\n      }\n    } else if (!scanning && char === ',' && closingBraces - openingBraces === 1) {\n      // closingBraces - openingBraces === 1 means we are in top-level braces\n      span = pattern.substring(handledUntil + 1, i)\n      alternatives.push(expand(span))\n      handledUntil = i\n    }\n\n    if (scanning && (closingBraces === openingBraces || i === pattern.length - 1)) {\n      scanning = false\n      i = handledUntil - 1\n    }\n  }\n\n  if (handledUntil === -1) {\n    return [pattern]\n  }\n\n  let unhandledFrom = pattern[handledUntil] === '{' ? handledUntil : handledUntil + 1\n  if (unhandledFrom < pattern.length) {\n    span = pattern.substr(unhandledFrom)\n    for (let j = 0; j < results.length; j++) {\n      results[j] += span\n    }\n  }\n\n  return results\n}\n\nexport default expand\n","import { OutmatchOptions } from './common'\n\nfunction negate(pattern: string, options: OutmatchOptions) {\n  let supportNegation = options['!'] !== false\n  let supportParens = options['()'] !== false\n  let isNegated = false\n  let i: number\n\n  if (supportNegation) {\n    // Consume leading !s unless the next char is an opening paren. At this point we can't\n    // be sure if it's a valid negated glob or just a wild paren, so this can produce false results.\n    for (i = 0; i < pattern.length && pattern[i] === '!'; i++) {\n      if (supportParens && pattern[i + 1] === '(') {\n        i--\n        break\n      }\n      isNegated = !isNegated\n    }\n\n    if (i > 0) {\n      pattern = pattern.substr(i)\n    }\n  }\n\n  return { pattern, isNegated }\n}\n\nexport default negate\n","interface OutmatchOptions {\n  separator?: boolean | string\n  flags?: string\n  excludeDot?: boolean\n  '!'?: boolean\n  '?'?: boolean\n  '*'?: boolean\n  '**'?: boolean\n  '[]'?: boolean\n  '()'?: boolean\n  '{}'?: boolean\n}\n\nfunction escapeRegExpChar(char: string) {\n  if (\n    char === '-' ||\n    char === '^' ||\n    char === '$' ||\n    char === '+' ||\n    char === '.' ||\n    char === '(' ||\n    char === ')' ||\n    char === '|' ||\n    char === '[' ||\n    char === ']' ||\n    char === '{' ||\n    char === '}' ||\n    char === '*' ||\n    char === '?' ||\n    char === '\\\\'\n  ) {\n    return `\\\\${char}`\n  } else {\n    return char\n  }\n}\n\nfunction escapeRegExpString(str: string) {\n  let result = ''\n  for (let i = 0; i < str.length; i++) {\n    result += escapeRegExpChar(str[i])\n  }\n  return result\n}\n\nexport { OutmatchOptions, escapeRegExpChar, escapeRegExpString }\n","import { escapeRegExpString, OutmatchOptions } from './common'\n\nfunction Pattern(source: string, options: OutmatchOptions, excludeDot: boolean) {\n  let separator = typeof options.separator === 'undefined' ? true : options.separator\n  let separatorSplitter = ''\n  let separatorMatcher = ''\n  let wildcard = '.'\n\n  if (separator === true) {\n    // In this case forward slashes in patterns match both forward and backslashes in samples\n    separatorSplitter = '/'\n    separatorMatcher = '[/\\\\\\\\]'\n    wildcard = '[^/\\\\\\\\]'\n  } else if (separator) {\n    separatorSplitter = separator\n    separatorMatcher = escapeRegExpString(separatorSplitter)\n\n    if (separatorMatcher.length > 1) {\n      separatorMatcher = `(?:${separatorMatcher})`\n      wildcard = `((?!${separatorMatcher}).)`\n    } else {\n      wildcard = `[^${separatorMatcher}]`\n    }\n  } else {\n    wildcard = '.'\n  }\n\n  // When a separator is explicitly specified in a pattern, it must match _one or more_\n  // separators in a sample, so we use quantifiers. When a pattern doesn't have a trailing\n  // separator, a sample can still optionally have them, so we use different quantifiers\n  // depending on the index of a segment.\n  let requiredSeparator = separator ? `${separatorMatcher}+?` : ''\n  let optionalSeparator = separator ? `${separatorMatcher}*?` : ''\n\n  let segments = separator ? source.split(separatorSplitter) : [source]\n\n  let support = {\n    qMark: options['?'] !== false,\n    star: options['*'] !== false,\n    globstar: separator && options['**'] !== false,\n    brackets: options['[]'] !== false,\n    extglobs: options['()'] !== false,\n    // The excludeDot function argument is for cases when we don't want to exclude leading\n    // dots even if the option is true (negated patterns).\n    excludeDot: excludeDot && options.excludeDot !== false,\n  }\n\n  return {\n    source,\n    segments,\n    options,\n    separator,\n    separatorSplitter,\n    separatorMatcher,\n    optionalSeparator,\n    requiredSeparator,\n    wildcard,\n    support,\n  }\n}\n\nfunction Segment(\n  source: string,\n  pattern: ReturnType<typeof Pattern>,\n  isFirst: boolean,\n  isLast: boolean\n) {\n  return {\n    source,\n    isFirst,\n    isLast,\n    end: source.length - 1,\n  }\n}\n\nfunction Result() {\n  // To support negated extglobs, we maintain two result patterns called `match` and `unmatch`.\n  // They are built identically except for two things:\n  // 1. Negated extglobs.\n  //    In `match` they become `wildcard + *`, i.e. \"match everything but the separator\".\n  //    In `unmatch` they become a regular positive regexp group.\n  // 2. Patterns for excluding leading dots.\n  //    They are added to `match` and skipped in `unmatch`.\n  // `useUnmatch` is set to true if we actually encounter a negated extglob. In that case\n  // the returned pattern is `'(?!^' + unmatch + '$)' + match`, otherwise it's just `match`.\n  return {\n    match: '',\n    unmatch: '',\n    useUnmatch: false,\n  }\n}\n\nfunction State(\n  pattern: ReturnType<typeof Pattern>,\n  segment: ReturnType<typeof Segment>,\n  result: ReturnType<typeof Result>\n) {\n  return {\n    pattern,\n    segment,\n    result,\n    openingBracket: segment.end + 1,\n    closingBracket: -1,\n    openingParens: 0,\n    closingParens: 0,\n    parensHandledUntil: -1,\n    extglobModifiers: [] as string[],\n    scanningForParens: false,\n    escapeChar: false,\n    addToMatch: true,\n    addToUnmatch: pattern.support.extglobs,\n    // We need to add the dot exclusion pattern before a segment only if it starts\n    // with a wildcard and not a literal character.\n    dotHandled: false,\n    i: -1,\n    char: '',\n    nextChar: '',\n  }\n}\n\nexport { Pattern, Segment, Result, State }\n","import { Pattern, Segment, Result, State } from './entities'\nimport { escapeRegExpChar, OutmatchOptions } from './common'\n\n// We use typescript-transform-macros to inline functions that handle various glob features.\n// These functions are called for every char in a pattern, and using them without explicit\n// inlining degrades performance. Having them in a separate file would be nice, but it\n// isn't supported, unfortunately.\ndeclare function MACRO<T>(t: T): T\n\n// This is used in place of the return value in inlined functions to skip to the next char\nconst CONTINUE = MACRO(() => {\n  // @ts-expect-error\n  continue\n})\n\nconst EXCLUDE_DOT_PATTERN = '(?!\\\\.)'\n\nfunction add(state: ReturnType<typeof State>, addition: string, excludeDot?: boolean) {\n  if (state.addToUnmatch) {\n    state.result.unmatch += addition\n  }\n\n  if (state.addToMatch) {\n    if (excludeDot && !state.dotHandled) {\n      addition = EXCLUDE_DOT_PATTERN + addition\n    }\n\n    state.dotHandled = true\n    state.result.match += addition\n  }\n\n  return state.result\n}\n\nconst convertEscaping = MACRO((state: ReturnType<typeof State>) => {\n  // The straightforward way to handle escaping would be to add the next character\n  // to the result as soon as a backslash is found and skip the rest of the current iteration.\n  // However, some processing has to be triggered for the last char in a pattern no matter\n  // if it is escaped or not, so we can't do this. Instead, we set the escapeChar flag\n  // for the next char and handle it in the next iteration (in which we have to be\n  // extra careful to reset the flag whenever the iteration completes or continues)\n  if (state.char === '\\\\') {\n    if (state.i < state.segment.end) {\n      state.escapeChar = true\n      return CONTINUE()\n    } else {\n      // If the last char in a pattern is a backslash, it is ignored\n      state.char = ''\n    }\n  }\n})\n\nconst convertBrackets = MACRO((state: ReturnType<typeof State>) => {\n  let { pattern, segment, char, i } = state\n\n  if (pattern.support.brackets && !state.scanningForParens) {\n    if (i > state.openingBracket && i <= state.closingBracket) {\n      // We are certainly in a complete character class\n      // and should treat almost all characters literally\n      if (state.escapeChar) {\n        add(state, escapeRegExpChar(char))\n      } else if (i === state.closingBracket) {\n        add(state, ']')\n        state.openingBracket = segment.source.length\n      } else if (char === '-' && i === state.closingBracket - 1) {\n        add(state, '\\\\-')\n      } else if (char === '!' && i === state.openingBracket + 1) {\n        add(state, '^')\n      } else if (char === ']') {\n        add(state, '\\\\]')\n      } else {\n        add(state, char)\n      }\n      state.escapeChar = false\n      return CONTINUE()\n    }\n\n    if (i > state.openingBracket) {\n      // We are in an open character class and are looking for a closing bracket\n      // to make sure the class is terminated\n      if (\n        char === ']' &&\n        !state.escapeChar &&\n        i > state.openingBracket + 1 &&\n        i > state.closingBracket\n      ) {\n        // Closing bracket is found; return to openingBracket\n        // and treat all the in-between chars literally\n        state.closingBracket = i\n        state.i = state.openingBracket\n        if (pattern.separator) {\n          add(state, `(?!${pattern.separatorMatcher})[`, true)\n        } else {\n          add(state, '[', true)\n        }\n      } else if (i === segment.end) {\n        // Closing bracket is not found; return to the opening bracket\n        // and treat all the in-between chars as usual\n        add(state, '\\\\[')\n        state.i = state.openingBracket\n        state.openingBracket = segment.source.length\n        state.closingBracket = segment.source.length\n      }\n      state.escapeChar = false\n      return CONTINUE()\n    }\n\n    // An opening bracket is found; commence scanning for a closing bracket\n    if (\n      char === '[' &&\n      !state.escapeChar &&\n      i > state.closingBracket &&\n      i < segment.end\n    ) {\n      state.openingBracket = i\n      state.escapeChar = false\n      return CONTINUE()\n    }\n  }\n})\n\nconst convertExtglob = MACRO((state: ReturnType<typeof State>) => {\n  if (state.pattern.support.extglobs) {\n    let { extglobModifiers, char, nextChar, i } = state\n\n    // When we find an opening extglob paren, we start counting opening and closing\n    // parens and ignoring other chars until all the opened extglobes are closed\n    // or the pattern ends. After we have counted the parens, we return to the char\n    // we started from and proceed normally while transforming the extglobs that have\n    // a closing paren.\n    if (\n      nextChar === '(' &&\n      !state.escapeChar &&\n      (char === '@' || char === '?' || char === '*' || char === '+' || char === '!')\n    ) {\n      if (state.scanningForParens) {\n        state.openingParens++\n      } else if (i > state.parensHandledUntil && !state.closingParens) {\n        state.parensHandledUntil = i\n        state.scanningForParens = true\n        state.openingParens++\n      } else if (state.closingParens >= state.openingParens) {\n        if (char === '!') {\n          state.addToMatch = true\n          state.addToUnmatch = false\n          add(state, `${state.pattern.wildcard}*?`, true)\n          state.addToMatch = false\n          state.addToUnmatch = true\n          state.result.useUnmatch = true\n        }\n        extglobModifiers.push(char)\n        add(state, '(?:', true)\n        state.openingParens--\n        state.i++\n        return CONTINUE()\n      } else {\n        state.openingParens--\n      }\n    } else if (char === ')' && !state.escapeChar) {\n      if (state.scanningForParens) {\n        state.closingParens++\n      } else if (extglobModifiers.length) {\n        let modifier = extglobModifiers.pop()\n        if (modifier === '!' && extglobModifiers.indexOf('!') !== -1) {\n          throw new Error(\"Nested negated extglobs aren't supported\")\n        }\n        modifier = modifier === '!' || modifier === '@' ? '' : modifier\n        add(state, `)${modifier}`)\n        state.addToMatch = true\n        state.addToUnmatch = true\n        state.closingParens--\n        return CONTINUE()\n      }\n    } else if (\n      char === '|' &&\n      state.closingParens &&\n      !state.scanningForParens &&\n      !state.escapeChar\n    ) {\n      add(state, '|')\n      return CONTINUE()\n    }\n\n    if (state.scanningForParens) {\n      if (state.closingParens === state.openingParens || i === state.segment.end) {\n        state.scanningForParens = false\n        state.i = state.parensHandledUntil - 1\n      }\n      state.escapeChar = false\n      return CONTINUE()\n    }\n  }\n})\n\nconst convertSingleChar = MACRO((state: ReturnType<typeof State>) => {\n  let { pattern } = state\n  let { support } = pattern\n\n  if (!state.escapeChar && support.star && state.char === '*') {\n    if (state.i === state.segment.end || state.nextChar !== '*') {\n      add(state, `${pattern.wildcard}*?`, true)\n    }\n  } else if (!state.escapeChar && support.qMark && state.char === '?') {\n    add(state, pattern.wildcard, true)\n  } else {\n    add(state, escapeRegExpChar(state.char))\n  }\n})\n\nfunction convertSegment(\n  pattern: ReturnType<typeof Pattern>,\n  segment: ReturnType<typeof Segment>,\n  result: ReturnType<typeof Result>\n) {\n  let { support } = pattern\n  let state = State(pattern, segment, result)\n  let separatorMatcher = segment.isLast\n    ? pattern.optionalSeparator\n    : pattern.requiredSeparator\n\n  if (!support.excludeDot) {\n    state.dotHandled = true\n  }\n\n  if (segment.end === -1) {\n    return segment.isLast && !segment.isFirst ? result : add(state, separatorMatcher)\n  }\n\n  if (support.globstar && segment.source === '**') {\n    let prefix = !state.dotHandled ? EXCLUDE_DOT_PATTERN : ''\n    let globstarSegment = `${prefix + pattern.wildcard}*?${separatorMatcher}`\n    return add(state, `(?:${globstarSegment})*?`)\n  }\n\n  while (++state.i <= segment.end) {\n    state.char = state.segment.source[state.i]\n    state.nextChar = state.i < segment.end ? segment.source[state.i + 1] : ''\n\n    // The order is important\n    convertEscaping(state)\n    convertBrackets(state)\n    convertExtglob(state)\n    convertSingleChar(state)\n\n    state.escapeChar = false\n  }\n\n  return add(state, separatorMatcher)\n}\n\nfunction convert(source: string, options: OutmatchOptions, excludeDot: boolean) {\n  let pattern = Pattern(source, options, excludeDot)\n  let result = Result()\n  let { segments } = pattern\n\n  for (let i = 0; i < segments.length; i++) {\n    let segment = Segment(segments[i], pattern, i === 0, i === segments.length - 1)\n    convertSegment(pattern, segment, result)\n  }\n\n  if (result.useUnmatch) {\n    return `(?!^${result.unmatch}$)${result.match}`\n  } else {\n    return result.match\n  }\n}\n\nexport default convert\n","import type { OutmatchOptions } from './common'\nimport expand from './expand'\nimport negate from './negate'\nimport convert from './convert'\n\nfunction flatMap<T, R>(array: Array<T>, predicate: (arg: T) => Array<R>) {\n  let results = []\n  for (let i = 0; i < array.length; i++) {\n    let mappedValue = predicate(array[i])\n    for (let j = 0; j < mappedValue.length; j++) {\n      results.push(mappedValue[j])\n    }\n  }\n  return results\n}\n\nfunction compile(patterns: string | string[], options: OutmatchOptions) {\n  patterns = Array.isArray(patterns) ? patterns : [patterns]\n\n  if (options['{}'] !== false) {\n    patterns = flatMap(patterns, expand)\n  }\n\n  let positiveResults = []\n  let negativeResults = []\n  let result = ''\n\n  for (let i = 0; i < patterns.length; i++) {\n    let negatedPattern = negate(patterns[i], options)\n    let convertedPattern = convert(\n      negatedPattern.pattern,\n      options,\n      !negatedPattern.isNegated\n    )\n\n    if (negatedPattern.isNegated) {\n      negativeResults.push(convertedPattern)\n    } else {\n      positiveResults.push(convertedPattern)\n    }\n  }\n\n  if (negativeResults.length) {\n    result = `(?!(?:${negativeResults.join('|')})$)`\n  }\n\n  if (positiveResults.length > 1) {\n    result += `(?:${positiveResults.join('|')})`\n  } else if (positiveResults.length === 1) {\n    result += positiveResults[0]\n  } else if (result.length) {\n    result += convert('**', options, true)\n  }\n\n  return `^${result}$`\n}\n\ninterface isMatch {\n  /**\n   * Tests if a sample string matches the pattern(s)\n   *\n   * ```js\n   * isMatch('foo') //=> true\n   * ```\n   */\n  (sample: string): boolean\n\n  /** The compiled regular expression */\n  regexp: RegExp\n\n  /** The original pattern or array of patterns that was used to compile the RegExp */\n  pattern: string | string[]\n\n  /** The options that were used to compile the RegExp */\n  options: OutmatchOptions\n}\n\nfunction isMatch(regexp: RegExp, sample: string) {\n  if (typeof sample !== 'string') {\n    throw new TypeError(`Sample must be a string, but ${typeof sample} given`)\n  }\n\n  return regexp.test(sample)\n}\n\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns true\n * if the string matches the pattern(s).\n *\n * ```js\n * outmatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = outmatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction outmatch(\n  pattern: string | string[],\n  options?: OutmatchOptions | string | boolean\n): isMatch {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError(\n      `The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`\n    )\n  }\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    options = { separator: options }\n  }\n\n  if (\n    arguments.length === 2 &&\n    !(\n      typeof options === 'undefined' ||\n      (typeof options === 'object' && options !== null && !Array.isArray(options))\n    )\n  ) {\n    throw new TypeError(\n      `The second argument must be an options object or a string/boolean separator, but ${typeof options} given`\n    )\n  }\n\n  options = options || {}\n\n  if (options.separator === '\\\\') {\n    throw new Error('\\\\ is not a valid separator')\n  }\n\n  let regexpPattern = compile(pattern, options)\n  let regexp = new RegExp(regexpPattern, options.flags)\n\n  let fn = isMatch.bind(null, regexp) as isMatch\n  fn.options = options\n  fn.pattern = pattern\n  fn.regexp = regexp\n  return fn\n}\n\nexport default outmatch\n"],"names":[],"mappings":"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"}