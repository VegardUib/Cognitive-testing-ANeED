"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const compiler_1 = require("svelte/compiler");
const svgo_1 = require("svgo");
const { readFile } = fs_1.promises;
function isCompileError(err) {
    return err instanceof Error && 'code' in err && 'frame' in err;
}
const svgRegex = /(<svg.*?)(>.*)/s;
function color(start, end = '\u001b[0m') {
    return (text) => `${start}${text}${end}`;
}
const yellow = color('\u001b[33m');
const blue = color('\u001b[34m');
function addComponentProps(data) {
    const parts = svgRegex.exec(data);
    if (!parts) {
        throw new Error('Invalid SVG');
    }
    const [, head, body] = parts;
    return `${head} {...$$props}${body}`;
}
function isSvgoOptimizeError(obj) {
    return typeof obj === 'object' && obj !== null && !('data' in obj);
}
function hasCdata(code) {
    return code.includes('<![CDATA[');
}
function readSvg(options = { type: 'component' }) {
    const resvg = /\.svg(?:\?(src|url|component|dataurl)(=(base64|(un)?enc))?)?$/;
    if (options.includePaths) {
        // Normalize the include paths prefixes ahead of time
        options.includePaths = options.includePaths.map((pattern) => {
            const filepath = path_1.default.resolve(path_1.default.normalize(pattern));
            return path_1.default.sep === '\\' ? filepath.replace(/\\/g, '/') : filepath;
        });
    }
    const isType = (str, type) => {
        return (!str && options.type === type) || str === type;
    };
    return {
        name: 'sveltekit-svg',
        async transform(source, id, transformOptions) {
            var _a, _b;
            if (options.includePaths) {
                const isIncluded = options.includePaths.some((pattern) => {
                    return id.startsWith(pattern);
                });
                if (!isIncluded) {
                    return undefined;
                }
            }
            const match = id.match(resvg);
            if (!match) {
                return undefined;
            }
            const isBuild = (_a = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.ssr) !== null && _a !== void 0 ? _a : false;
            const type = match[1];
            if (isType(type, 'url')) {
                return source;
            }
            let svgo = options.svgoOptions;
            let isSvgoDataUri = false;
            if (svgo && typeof svgo === 'object') {
                if (svgo.datauri) {
                    isSvgoDataUri = true;
                }
            }
            if (isSvgoDataUri && type === 'component') {
                console.warn(`%s Type %O can not be imported as a Svelte component ` +
                    `since "datauri" is set in vite.config`, yellow('[WARNING]'), id);
            }
            else if (type === 'dataurl') {
                const t = (_b = match[3]) !== null && _b !== void 0 ? _b : 'base64';
                if (!svgo) {
                    svgo = {};
                }
                svgo.datauri = t;
                isSvgoDataUri = true;
            }
            try {
                const filename = id.replace(/\.svg(\?.*)$/, '.svg');
                let data = (await readFile(filename)).toString('utf-8');
                const opt = svgo !== false
                    ? (0, svgo_1.optimize)(data, {
                        path: filename,
                        ...(svgo || {}),
                    })
                    : { data };
                if (isSvgoOptimizeError(opt)) {
                    console.error('Got optimize error from SVGO:', opt);
                    return undefined;
                }
                if (isType(type, 'src') || isSvgoDataUri) {
                    data = `\nexport default \`${opt.data}\`;`;
                }
                else {
                    opt.data = addComponentProps(opt.data);
                    const { js } = (0, compiler_1.compile)(opt.data, {
                        css: false,
                        filename: id,
                        hydratable: !isBuild,
                        namespace: 'svg',
                        generate: isBuild ? 'ssr' : 'dom',
                    });
                    data = js;
                }
                return data;
            }
            catch (err) {
                if (isCompileError(err) && hasCdata(err.frame)) {
                    const msg = `\n%s The SVG file %O contains a %s section which is not ` +
                        `supported by Svelte. To make this SVG work with the %s ` +
                        `plugin, you need to remove all %s sections from the SVG.\n`;
                    console.warn(msg, yellow('[WARNING]'), id, blue('<![CDATA[...]]>'), blue('@poppanator/sveltekit-svg'), blue('<![CDATA[...]]>'));
                }
                else {
                    console.error('Failed reading SVG "%s": %s', id, err.message, err);
                }
                return undefined;
            }
        },
    };
}
module.exports = readSvg;
